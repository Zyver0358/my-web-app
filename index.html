<!DOCTYPE html>
<html>
<head>
    <link rel="manifest" href="manifest.json">

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js');
  }
</script>
    <title>DBD 2D - Full Feature Build</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; width: 800px; height: 900px; border: 4px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        @media (min-width: 1000px) { #game-container { width: 900px; height: 700px; } }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        .ui { position: fixed; top: 10px; left: 10px; color: white; z-index: 100; pointer-events: none; text-shadow: 2px 2px 2px black; font-size: 14px; }
        
        .joystick-container { display: none; position: fixed; bottom: 300px; width: 100%; justify-content: space-between; padding: 0 50px; box-sizing: border-box; pointer-events: auto; z-index: 1000; }
        @media (max-width: 1024px) { .joystick-container { display: flex; } }
        .joystick-base { width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; position: relative; pointer-events: auto; }
        .joystick-stick { width: 50px; height: 50px; background: rgba(255, 255, 255, 0.5); border-radius: 50%; position: absolute; top: 35px; left: 35px; pointer-events: none; }
    </style>
</head>
<body>

    <div class="ui">
        <span class="pc-controls"><b>WASD</b> to Move | <b>M1</b> to Attack</span>
        <span class="mobile-controls" style="display:none;">Use <b>Joysticks</b> to Move & Aim</span><br>
        <span id="status-text">Trial in Progress...</span>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="joystick-container" id="mobile-ui">
        <div id="move-joystick" class="joystick-base"><div class="joystick-stick"></div></div>
        <div id="aim-joystick" class="joystick-base"><div class="joystick-stick"></div></div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mobileZoom = 0.85; // zoom out a bit on phones


// --- MOBILE DETECTION ---
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
if (isMobile) {
    document.querySelector('.pc-controls').style.display = 'none';
    document.querySelector('.mobile-controls').style.display = 'inline';
}

const world = { width: 3000, height: 3000 };
let screen = { width: 800, height: 900 };

// --- 1. RESOURCE LOADING ---
const textures = {};
const textureFiles = { GEN: 'GEN.png', HOOK:'HOOK.png' };
const playerTextures = {};
const directions = ['down', 'up', 'left', 'right', 'down_left', 'down_right', 'up_left', 'up_right'];
let loadedPlayers = 0;

directions.forEach(dir => {
    playerTextures[dir] = new Image();
    playerTextures[dir].src = `killer_${dir}.png`; 
    playerTextures[dir].onload = () => loadedPlayers++;
    playerTextures[dir].onerror = () => loadedPlayers++;
});

const barrelFrames = [];
const totalBarrelFrames = 4;
let loadedBarrelFrames = 0;
for (let i = 1; i <= totalBarrelFrames; i++) {
    const img = new Image();
    img.src = `fire_barrel${i}.png`; 
    img.onload = () => loadedBarrelFrames++;
    img.onerror = () => loadedBarrelFrames++;
    barrelFrames.push(img);
}

let loadedCount = 0, allAssetsLoaded = false;
const textureKeys = Object.keys(textureFiles);
textureKeys.forEach(key => {
    textures[key] = new Image();
    textures[key].src = textureFiles[key];
    textures[key].onload = () => { loadedCount++; if (loadedCount === textureKeys.length) allAssetsLoaded = true; };
    textures[key].onerror = () => { loadedCount++; };
});

// --- 2. PLAYER & MAP DATA ---
const player = {
    x: world.width / 2, y: world.height / 2,
    w: 45, h: 92, offsetY: 15, color: "#ff0000",
    hitW: 40, hitH: 24, speed: 8, angle: 0, attackRange: 150
};

const mapObjects = [
    {name: "Main Saloon Hook"},
    { x: 1200, y: 1200, w: 200, h: 70, angle: 45, color: "#444", type: "WALL1", solid: true },
    { x: 1800, y: 1400, w: 200, h: 30, angle: 0, color: "#2d362d", type: "WALL2", solid: true },
    { x: 1915, y: 1485, w: 200, h: 30, angle: 90, color: "#2d362d", type: "WALL2", solid: true },
    { x: 1800, y: 1430, w: 200, h: 70, angle: 0, color: "#444", type: "WALL1", solid: true },
    { x: 1000, y: 1200, w: 200, h: 30, angle: 0, color: "#ffffff", type: "EXTERNAL_WALL1", solid: true },
    { x: 1000, y: 1230, w: 200, h: 150, angle: 0, color: "#ffff00", type: "EXTERNAL_WALL2", solid: true },
    { x: 1400, y: 1100, w: 85, h: 85, angle: 45, color: "#555", type: "GEN", solid: true },
    { x: 1600, y: 1800, w: 85, h: 85, angle: 0, color: "#555", type: "GEN", solid: true },
    { x: 2000, y: 2000, w: 40, h: 60, angle: 0, color: '#e67e22', type: "FIRE_BARRELS", solid: true },
    { x: 1300, y: 1500, w: 40, h: 60, angle: 0, color: '#e67e22', type: "FIRE_BARRELS", solid: true },
    { x: 1100, y: 1400, w: 80, h: 20, angle: 90, color: "#8B4513", type: "PALLET", solid: true },
    { x: 1250, y: 1100, w: 40, h: 40, angle: 0, color: "#222", type: "LOCKER", solid: true },
    { x: 1000, y: 1000, w: 20, h: 20, angle: 0, color: "#fff", type: "TOTEM", solid: false },
    { x: 1400, y: 1350, w: 70, h: 10, angle: 0, color: "#add8e6", type: "WINDOW", solid: false },
    { x: 1550, y: 1450, w: 25, h: 25, angle: 0, color: "#ff4500", type: "HOOK", solid: true },
    { x: 1500, y: 1500, w: 50, h: 50, angle: 0, color: "#000", type: "HATCH", solid: false },
    { x: 1400, y: 200, w: 200, h: 40, angle: 0, color: "#111", type: "EXIT", solid: true }
];

// --- 3. HELPER FUNCTIONS ---
function getPlayerDirection8() {
    let angle = player.angle;
    while (angle < 0) angle += Math.PI * 2;
    while (angle >= Math.PI * 2) angle -= Math.PI * 2;
    const step = Math.PI / 4;
    if (angle < step / 2 || angle >= 7.5 * step) return 'right';
    if (angle < 1.5 * step) return 'down_right';
    if (angle < 2.5 * step) return 'down';
    if (angle < 3.5 * step) return 'down_left';
    if (angle < 4.5 * step) return 'left';
    if (angle < 5.5 * step) return 'up_left';
    if (angle < 6.5 * step) return 'up';
    return 'up_right';
}

function isColliding(nx, ny) {
    for (let obj of mapObjects) {
        if (!obj.solid) continue;
        const angle = (obj.angle || 0) * (Math.PI / 180);
        const cx = obj.x + obj.w / 2, cy = obj.y + obj.h / 2;
        const cos = Math.cos(-angle), sin = Math.sin(-angle);
        const unX = (nx - cx) * cos - (ny - cy) * sin;
        const unY = (nx - cx) * sin + (ny - cy) * cos;
        if (Math.abs(unX) < (obj.w + player.hitW)/2 && Math.abs(unY) < (obj.h + player.hitH)/2) return true;
    }
    return false;
}

// --- 4. INPUT HANDLING ---
const joyInput = { move: { x: 0, y: 0 }, aim: { x: 0, y: 0 } };
const keys = {};
window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

function setupJoystick(id, type) {
    const base = document.getElementById(id);
    const stick = base.querySelector('.joystick-stick');
    const limit = 40;

    let touchId = null;

    const updateStick = (clientX, clientY) => {
        const rect = base.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;

        let dx = clientX - cx;
        let dy = clientY - cy;

        const dist = Math.hypot(dx, dy);
        if (dist > limit) {
            dx = (dx / dist) * limit;
            dy = (dy / dist) * limit;
        }

        stick.style.transform = `translate(${dx}px, ${dy}px)`;
        joyInput[type].x = dx / limit;
        joyInput[type].y = dy / limit;
    };

    base.addEventListener("touchstart", e => {
        e.preventDefault();
        const t = e.changedTouches[0];
        touchId = t.identifier;
        updateStick(t.clientX, t.clientY);
    }, { passive: false });

    document.addEventListener("touchmove", e => {
        if (touchId === null) return;
        for (let t of e.touches) {
            if (t.identifier === touchId) {
                updateStick(t.clientX, t.clientY);
                break;
            }
        }
    }, { passive: false });

    document.addEventListener("touchend", e => {
        for (let t of e.changedTouches) {
            if (t.identifier === touchId) {
                touchId = null;
                stick.style.transform = `translate(0,0)`;
                joyInput[type].x = 0;
                joyInput[type].y = 0;
                break;
            }
        }
    });
}


if (isMobile) {
    setupJoystick('move-joystick', 'move');
    setupJoystick('aim-joystick', 'aim');
}

// --- 5. UPDATE & DRAW ---
let barrelFrameIndex = 0, barrelFrameTimer = 0;

function update() {
    let moveX = joyInput.move.x, moveY = joyInput.move.y;
    if (keys['w'] || keys['arrowup']) moveY = -1;
    if (keys['s'] || keys['arrowdown']) moveY = 1;
    if (keys['a'] || keys['arrowleft']) moveX = -1;
    if (keys['d'] || keys['arrowright']) moveX = 1;

    if (Math.abs(moveX) > 0.1 || Math.abs(moveY) > 0.1) player.angle = Math.atan2(moveY, moveX);
    if (Math.abs(joyInput.aim.x) > 0.1 || Math.abs(joyInput.aim.y) > 0.1) player.angle = Math.atan2(joyInput.aim.y, joyInput.aim.x);

    let speed = (moveX !== 0 && moveY !== 0) ? player.speed * 0.7071 : player.speed;
    if (!isColliding(player.x + moveX * speed, player.y)) player.x += moveX * speed;
    if (!isColliding(player.x, player.y + moveY * speed)) player.y += moveY * speed;

    barrelFrameTimer++;
    if (barrelFrameTimer >= 8) {
        barrelFrameIndex = (barrelFrameIndex + 1) % totalBarrelFrames;
        barrelFrameTimer = 0;
    }
}

function setupCanvas() {
    const dpr = window.devicePixelRatio || 1;

    if (isMobile) {
        screen.width = window.innerWidth;
        screen.height = window.innerHeight;
    } else {
        screen.width = window.innerWidth >= 1000 ? 900 : 800;
        screen.height = window.innerWidth >= 1000 ? 700 : 900;
    }

    canvas.width = Math.floor(screen.width * dpr);
    canvas.height = Math.floor(screen.height * dpr);

    canvas.style.width = screen.width + "px";
    canvas.style.height = screen.height + "px";

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;
}
setupCanvas();
window.onresize = setupCanvas;

function draw() {
    ctx.clearRect(0, 0, screen.width, screen.height);
    ctx.save();
    ctx.translate(Math.round(screen.width/2 - player.x), Math.round(screen.height/2 - player.y));

    // Floor
    ctx.fillStyle = "#1a211a";
    ctx.fillRect(0, 0, world.width, world.height);

    // Objects Rendering
    mapObjects.forEach(obj => {
        if (obj.type === "FIRE_BARRELS") {
            const baseRadius = 60, flickerAmount = 5, flickerSpeed = 300;
            const glowSize = baseRadius + (Math.sin(Date.now() / flickerSpeed) * flickerAmount);
            ctx.save();
            const glowGrad = ctx.createRadialGradient(obj.x + obj.w/2, obj.y + obj.h/2, 0, obj.x + obj.w/2, obj.y + obj.h/2, glowSize);
            glowGrad.addColorStop(0, "rgba(230, 126, 34, 0.3)");
            glowGrad.addColorStop(1, "rgba(230, 126, 34, 0)");
            ctx.fillStyle = glowGrad;
            ctx.fillRect(obj.x + obj.w/2 - glowSize, obj.y + obj.h/2 - glowSize, glowSize * 2, glowSize * 2);
            ctx.restore();

            const img = barrelFrames[barrelFrameIndex];
            if (img && img.complete && img.naturalWidth !== 0) {
                ctx.drawImage(img, obj.x, obj.y, obj.w, obj.h);
            } else {
                ctx.fillStyle = obj.color; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            }
        } else {
            ctx.save();
            ctx.translate(obj.x + obj.w / 2, obj.y + obj.h / 2);
            ctx.rotate((obj.angle || 0) * (Math.PI / 180));
            const tex = textures[obj.type];
            if (tex && tex.complete && tex.naturalWidth !== 0) {
                ctx.drawImage(tex, -obj.w/2, -obj.h/2, obj.w, obj.h);
            } else {
                ctx.fillStyle = obj.color; ctx.fillRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
            }
            ctx.restore();
        }
    });

    // Attack Range (Red Stain)
    ctx.save();
    const grad = ctx.createRadialGradient(player.x, player.y+10, 0, player.x, player.y+10, player.attackRange);
    grad.addColorStop(0, "rgba(255, 0, 0, 0.4)"); grad.addColorStop(1, "rgba(255, 0, 0, 0)");
    ctx.beginPath();
    ctx.moveTo(player.x, player.y+10);
    ctx.arc(player.x, player.y+10, player.attackRange, player.angle - 0.5, player.angle + 0.5);
    ctx.fillStyle = grad; ctx.fill();
    ctx.restore();

    // Player Rendering (Safe Version)
    const currentDir = getPlayerDirection8();
    const activeTexture = playerTextures[currentDir];
    ctx.save();
    ctx.translate(player.x, player.y - player.offsetY);
    if (activeTexture && activeTexture.complete && activeTexture.naturalWidth !== 0) {
        ctx.drawImage(activeTexture, -player.w/2, -player.h/2, player.w, player.h);
    } else {
        ctx.fillStyle = player.color; ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
    }
    ctx.restore();

    ctx.restore();
    drawMinimap();
}

function drawMinimap() {
    const mmSize = 120, ratio = mmSize / world.width;
    ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
    ctx.fillRect(20, 20, mmSize, mmSize);
    mapObjects.forEach(obj => {
        ctx.fillStyle = obj.color;
        ctx.fillRect(20 + obj.x * ratio, 20 + obj.y * ratio, obj.w * ratio, obj.h * ratio);
    });
    ctx.fillStyle = "red";
    ctx.fillRect(20 + (player.x * ratio) - 2, 20 + (player.y * ratio) - 2, 4, 4);
}

function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
gameLoop();
</script>
</body>
</html>
